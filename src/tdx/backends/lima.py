"""Lima-backed build execution.

Manages a Lima VM instance for running mkosi builds on non-Linux hosts
(macOS, etc.), following the nethermind-tdx pattern of using a Debian VM
with mounted source directories.
"""

from __future__ import annotations

import json
import shutil
import subprocess
import textwrap
from dataclasses import dataclass, field
from pathlib import Path

from tdx.backends.base import MountSpec
from tdx.errors import BackendExecutionError
from tdx.models import ArtifactRef, BakeRequest, BakeResult, OutputTarget, ProfileBuildResult

LIMA_YAML_TEMPLATE = textwrap.dedent("""\
    # Generated by tdx SDK
    images:
      - location: "https://cloud.debian.org/images/cloud/trixie/daily/latest/debian-13-generic-amd64-daily.qcow2"
        arch: "x86_64"
    cpus: {cpus}
    memory: "{memory}"
    disk: "{disk}"
    mounts:
    {mounts}
    provision:
      - mode: system
        script: |
          #!/bin/bash
          set -eux
          apt-get update -qq
          apt-get install -y -qq mkosi systemd-container python3
    containerd:
      system: false
      user: false
""")


@dataclass(slots=True)
class LimaBackend:
    """Lima backend that manages a VM and runs mkosi builds inside it."""

    name: str = "lima"
    instance_name: str = "tdx-builder"
    mount_prefix: str = "/mnt/host"
    cpus: int = 4
    memory: str = "8GiB"
    disk: str = "40GiB"
    mkosi_args: list[str] = field(default_factory=list)

    def mount_plan(self, request: BakeRequest) -> tuple[MountSpec, ...]:
        """Mount plan is ordered and stable to avoid backend drift across runs."""
        mounts = [
            MountSpec(source=request.build_dir, target=f"{self.mount_prefix}/build"),
            MountSpec(source=request.emit_dir, target=f"{self.mount_prefix}/emit"),
        ]
        # Deterministic order by guest mount target.
        return tuple(sorted(mounts, key=lambda mount: mount.target))

    def prepare(self, request: BakeRequest) -> None:
        self._ensure_lima_available()
        for mount in self.mount_plan(request):
            mount.source.mkdir(parents=True, exist_ok=True)

        # Check if instance exists and is running
        if not self._instance_running():
            self._start_instance(request)

    def execute(self, request: BakeRequest) -> BakeResult:
        self._ensure_lima_available()

        # Map host paths to guest paths
        mounts = self.mount_plan(request)
        guest_emit = next(m.target for m in mounts if "emit" in m.target)
        guest_build = next(m.target for m in mounts if "build" in m.target)

        # Detect native profiles mode
        native_profiles_dir = request.emit_dir / "mkosi.profiles" / request.profile
        if native_profiles_dir.exists():
            mkosi_dir = guest_emit
            profile_flag = f"--profile={request.profile} "
        else:
            mkosi_dir = f"{guest_emit}/{request.profile}"
            profile_flag = ""

        output_dir = f"{guest_build}/{request.profile}/output"

        # Run mkosi inside the Lima VM
        mkosi_cmd = (
            f"mkdir -p {output_dir} && "
            f"cd {mkosi_dir} && "
            f"mkosi --force --image-id={request.profile} "
            f"--output-dir={output_dir} "
            f"{profile_flag}"
            f"{' '.join(self.mkosi_args)} build"
        )

        cmd = [
            "limactl",
            "shell",
            self.instance_name,
            "--",
            "bash",
            "-c",
            mkosi_cmd,
        ]

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False,
        )

        if result.returncode != 0:
            raise BackendExecutionError(
                "mkosi build failed inside Lima VM.",
                hint="Check Lima VM status with `limactl list` and mkosi output for details.",
                context={
                    "backend": self.name,
                    "operation": "execute",
                    "profile": request.profile,
                    "instance": self.instance_name,
                    "returncode": str(result.returncode),
                    "stderr": result.stderr[:2000] if result.stderr else "",
                    "command": " ".join(cmd),
                },
            )

        # Collect artifacts from the host-mounted output directory
        host_output_dir = request.build_dir / request.profile / "output"
        profile_result = ProfileBuildResult(profile=request.profile)
        profile_result.artifacts = self._collect_artifacts(host_output_dir)

        return BakeResult(profiles={request.profile: profile_result})

    def cleanup(self, request: BakeRequest) -> None:
        pass

    def stop(self) -> None:
        """Stop the Lima instance (call explicitly when done)."""
        if shutil.which("limactl") is None:
            return
        subprocess.run(
            ["limactl", "stop", self.instance_name],
            capture_output=True,
            check=False,
        )

    def _instance_running(self) -> bool:
        """Check if the Lima instance is running."""
        result = subprocess.run(
            ["limactl", "list", "--json"],
            capture_output=True,
            text=True,
            check=False,
        )
        if result.returncode != 0:
            return False
        try:
            for line in result.stdout.strip().splitlines():
                instance = json.loads(line)
                if instance.get("name") == self.instance_name:
                    return bool(instance.get("status") == "Running")
        except (json.JSONDecodeError, KeyError):
            pass
        return False

    def _start_instance(self, request: BakeRequest) -> None:
        """Start or create the Lima instance."""
        # Generate lima.yaml
        mounts = self.mount_plan(request)
        mounts_yaml = "\n".join(
            f'  - location: "{m.source}"\n    mountPoint: "{m.target}"\n    writable: true'
            for m in mounts
        )

        lima_config = LIMA_YAML_TEMPLATE.format(
            cpus=self.cpus,
            memory=self.memory,
            disk=self.disk,
            mounts=mounts_yaml,
        )

        config_path = request.build_dir / "lima.yaml"
        config_path.parent.mkdir(parents=True, exist_ok=True)
        config_path.write_text(lima_config, encoding="utf-8")

        # Start the instance
        result = subprocess.run(
            ["limactl", "start", "--name", self.instance_name, str(config_path)],
            capture_output=True,
            text=True,
            check=False,
        )

        if result.returncode != 0:
            raise BackendExecutionError(
                "Failed to start Lima VM instance.",
                hint="Check Lima installation and available disk space.",
                context={
                    "backend": self.name,
                    "operation": "start_instance",
                    "instance": self.instance_name,
                    "returncode": str(result.returncode),
                    "stderr": result.stderr[:2000] if result.stderr else "",
                },
            )

    def _collect_artifacts(self, output_dir: Path) -> dict[OutputTarget, ArtifactRef]:
        """Find output artifacts from mkosi build."""
        artifacts: dict[OutputTarget, ArtifactRef] = {}

        if not output_dir.exists():
            return artifacts

        for efi in sorted(output_dir.glob("*.efi*")):
            artifacts["qemu"] = ArtifactRef(target="qemu", path=efi)
            break

        for raw in sorted(output_dir.glob("*.raw*")):
            if "qemu" not in artifacts:
                artifacts["qemu"] = ArtifactRef(target="qemu", path=raw)
            break

        for qcow2 in sorted(output_dir.glob("*.qcow2*")):
            artifacts["qemu"] = ArtifactRef(target="qemu", path=qcow2)
            break

        for vhd in sorted(output_dir.glob("*.vhd*")):
            artifacts["azure"] = ArtifactRef(target="azure", path=vhd)
            break

        for tar_gz in sorted(output_dir.glob("*.tar.gz*")):
            artifacts["gcp"] = ArtifactRef(target="gcp", path=tar_gz)
            break

        return artifacts

    def _ensure_lima_available(self) -> None:
        if shutil.which("limactl") is None:
            raise BackendExecutionError(
                "Lima backend requires `limactl` in PATH.",
                hint="Install Lima and ensure `limactl` is available before running bake.",
                context={"backend": self.name, "operation": "prepare"},
            )
