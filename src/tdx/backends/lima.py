"""Lima-backed build execution.

Manages a Lima VM instance for running mkosi builds, following the
nethermind-tdx pattern of using a Debian VM with Nix and mounted source
directories. This is the default backend.
"""

from __future__ import annotations

import hashlib
import json
import shutil
import subprocess
import textwrap
from dataclasses import dataclass, field
from pathlib import Path

from tdx.backends.base import MountSpec
from tdx.errors import BackendExecutionError
from tdx.models import ArtifactRef, BakeRequest, BakeResult, OutputTarget, ProfileBuildResult

LIMA_YAML_TEMPLATE = textwrap.dedent("""\
    # Generated by tdx SDK
    images:
      - location: "https://cloud.debian.org/images/cloud/trixie/latest/debian-13-genericcloud-amd64.qcow2"
        arch: "x86_64"
      - location: "https://cloud.debian.org/images/cloud/trixie/latest/debian-13-genericcloud-arm64.qcow2"
        arch: "aarch64"
    cpus: {cpus}
    memory: "{memory}"
    disk: "{disk}"
    user:
      name: debian
      uid: 1000
      home: /home/debian
    rosetta:
      enabled: true
      binfmt: true
    containerd:
      user: false
    mountTypesUnsupported: [9p]
    mounts:
      - location: "{mount_source}"
        mountPoint: /home/debian/mnt
        writable: true
    ssh:
      forwardAgent: true
    provision:
      - mode: system
        script: |
          #!/bin/bash
          set -euo pipefail
          apt-get update
          apt-get install -y curl git sudo debian-archive-keyring build-essential uidmap
          echo "debian ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/debian
      - mode: user
        script: |
          #!/bin/bash
          set -euo pipefail
          mkdir -p ~/.config/nix
          echo 'experimental-features = nix-command flakes' > ~/.config/nix/nix.conf
          echo 'extra-platforms = x86_64-linux' >> ~/.config/nix/nix.conf
          sh <(curl -L https://nixos.org/nix/install) --no-daemon \
            --nix-extra-conf-file ~/.config/nix/nix.conf
          grep nix .profile >> .bashrc
""")

MKOSI_CACHE_DIR = "/home/debian/mkosi-cache"
MKOSI_OUTPUT_DIR = "/home/debian/mkosi-output"


@dataclass(slots=True)
class LimaBackend:
    """Lima backend that manages a VM and runs mkosi builds inside it.

    Follows the nethermind-tdx pattern: Debian Trixie VM with Nix,
    SSH-based execution, and separate cache/output directories inside the
    VM to avoid permission issues with host-mounted filesystems.
    """

    cpus: int = field(repr=True)
    memory: str = field(repr=True)
    disk: str = field(repr=True)
    name: str = "lima"
    instance_name: str | None = None
    mkosi_args: list[str] = field(default_factory=list)
    _last_instance: str | None = field(init=False, default=None, repr=False)

    def mount_plan(self, request: BakeRequest) -> tuple[MountSpec, ...]:
        """Single mount: build_dir â†’ /home/debian/mnt."""
        return (MountSpec(source=request.build_dir, target="/home/debian/mnt"),)

    def prepare(self, request: BakeRequest) -> None:
        self._ensure_lima_available()
        request.build_dir.mkdir(parents=True, exist_ok=True)
        request.emit_dir.mkdir(parents=True, exist_ok=True)

        instance = self._resolve_instance_name(request)
        self._last_instance = instance

        if not self._instance_running(instance):
            self._start_instance(instance, request)

    def execute(self, request: BakeRequest) -> BakeResult:
        self._ensure_lima_available()
        instance = self._resolve_instance_name(request)

        # Create cache/output dirs inside the VM (not on host mount)
        self._lima_exec(instance, f"mkdir -p {MKOSI_CACHE_DIR} {MKOSI_OUTPUT_DIR}")

        # Build the mkosi command
        mkosi_cmd = self._build_mkosi_command(request)

        # Run inside the VM via nix develop
        full_cmd = f"cd ~/mnt/mkosi && /home/debian/.nix-profile/bin/nix develop -c {mkosi_cmd}"
        result = self._lima_exec(instance, full_cmd)

        if result.returncode != 0:
            raise BackendExecutionError(
                "mkosi build failed inside Lima VM.",
                hint="Check Lima VM status with `limactl list` and mkosi output for details.",
                context={
                    "backend": self.name,
                    "operation": "execute",
                    "profile": request.profile,
                    "instance": instance,
                    "returncode": str(result.returncode),
                    "stderr": result.stderr[-2000:] if result.stderr else "",
                    "stdout": result.stdout[-2000:] if result.stdout else "",
                },
            )

        # Copy artifacts from VM-internal output dir to host-visible mount
        host_output = f"~/mnt/{request.profile}/output"
        self._lima_exec(
            instance,
            f"mkdir -p {host_output} && mv {MKOSI_OUTPUT_DIR}/* {host_output}/ 2>/dev/null || true",
        )

        # Collect artifacts from the host side
        output_dir = request.build_dir / request.profile / "output"
        profile_result = ProfileBuildResult(profile=request.profile)
        profile_result.artifacts = self._collect_artifacts(output_dir)

        return BakeResult(profiles={request.profile: profile_result})

    def cleanup(self, request: BakeRequest) -> None:
        pass

    def stop(self, instance: str | None = None) -> None:
        """Stop a Lima instance. Uses last-used instance if not specified."""
        if shutil.which("limactl") is None:
            return
        target = instance or self._last_instance
        if target is None:
            return
        subprocess.run(
            ["limactl", "stop", target],
            capture_output=True,
            check=False,
        )

    def _resolve_instance_name(self, request: BakeRequest) -> str:
        """Generate a unique VM name from the emit_dir path, or use override."""
        if self.instance_name is not None:
            return self.instance_name
        h = hashlib.sha256(str(request.emit_dir.resolve()).encode()).hexdigest()[:8]
        return f"tdx-builder-{h}"

    def _build_mkosi_command(self, request: BakeRequest) -> str:
        """Build the mkosi command string for execution inside the VM."""
        # Detect native profiles mode
        native_profiles_dir = request.emit_dir / "mkosi.profiles" / request.profile
        if native_profiles_dir.exists():
            profile_flag = f"--profile={request.profile} "
        else:
            profile_flag = ""

        extra_args = " ".join(self.mkosi_args)
        if extra_args:
            extra_args = f" {extra_args}"

        return (
            f"mkosi --force "
            f"--image-id={request.profile} "
            f"--cache-directory={MKOSI_CACHE_DIR} "
            f"--output-dir={MKOSI_OUTPUT_DIR} "
            f"{profile_flag}"
            f"{extra_args}"
            f"build"
        ).strip()

    def _lima_exec(self, instance: str, cmd: str) -> subprocess.CompletedProcess[str]:
        """Execute a command inside the Lima VM via SSH."""
        ssh_config = Path.home() / ".lima" / instance / "ssh.config"
        return subprocess.run(
            [
                "ssh",
                "-F",
                str(ssh_config),
                f"lima-{instance}",
                "-o",
                "LogLevel=QUIET",
                "--",
                "bash",
                "-c",
                cmd,
            ],
            capture_output=True,
            text=True,
            check=False,
        )

    def _instance_running(self, instance: str) -> bool:
        """Check if a Lima instance exists and is running."""
        result = subprocess.run(
            ["limactl", "list", "--json"],
            capture_output=True,
            text=True,
            check=False,
        )
        if result.returncode != 0:
            return False
        try:
            for line in result.stdout.strip().splitlines():
                data = json.loads(line)
                if data.get("name") == instance:
                    return bool(data.get("status") == "Running")
        except (json.JSONDecodeError, KeyError):
            pass
        return False

    def _start_instance(self, instance: str, request: BakeRequest) -> None:
        """Create and start a Lima instance."""
        mount_source = str(request.build_dir.resolve())

        lima_config = LIMA_YAML_TEMPLATE.format(
            cpus=self.cpus,
            memory=self.memory,
            disk=self.disk,
            mount_source=mount_source,
        )

        config_path = request.build_dir / "lima.yaml"
        config_path.parent.mkdir(parents=True, exist_ok=True)
        config_path.write_text(lima_config, encoding="utf-8")

        # Check if instance exists but is stopped
        exists = self._instance_exists(instance)

        if not exists:
            result = subprocess.run(
                [
                    "limactl",
                    "create",
                    "-y",
                    "--name",
                    instance,
                    str(config_path),
                ],
                capture_output=True,
                text=True,
                check=False,
            )
            if result.returncode != 0:
                raise BackendExecutionError(
                    "Failed to create Lima VM instance.",
                    hint="Check Lima installation and available disk space.",
                    context={
                        "backend": self.name,
                        "operation": "create_instance",
                        "instance": instance,
                        "returncode": str(result.returncode),
                        "stderr": result.stderr[-2000:] if result.stderr else "",
                    },
                )

        result = subprocess.run(
            ["limactl", "start", "-y", instance],
            capture_output=True,
            text=True,
            check=False,
        )
        if result.returncode != 0:
            raise BackendExecutionError(
                "Failed to start Lima VM instance.",
                hint="Check Lima installation and available disk space.",
                context={
                    "backend": self.name,
                    "operation": "start_instance",
                    "instance": instance,
                    "returncode": str(result.returncode),
                    "stderr": result.stderr[-2000:] if result.stderr else "",
                },
            )

    def _instance_exists(self, instance: str) -> bool:
        """Check if a Lima instance exists (running or stopped)."""
        result = subprocess.run(
            ["limactl", "list", "--json"],
            capture_output=True,
            text=True,
            check=False,
        )
        if result.returncode != 0:
            return False
        try:
            for line in result.stdout.strip().splitlines():
                data = json.loads(line)
                if data.get("name") == instance:
                    return True
        except (json.JSONDecodeError, KeyError):
            pass
        return False

    def _collect_artifacts(self, output_dir: Path) -> dict[OutputTarget, ArtifactRef]:
        """Find output artifacts from mkosi build."""
        artifacts: dict[OutputTarget, ArtifactRef] = {}

        if not output_dir.exists():
            return artifacts

        for efi in sorted(output_dir.glob("*.efi*")):
            artifacts["qemu"] = ArtifactRef(target="qemu", path=efi)
            break

        for raw in sorted(output_dir.glob("*.raw*")):
            if "qemu" not in artifacts:
                artifacts["qemu"] = ArtifactRef(target="qemu", path=raw)
            break

        for qcow2 in sorted(output_dir.glob("*.qcow2*")):
            artifacts["qemu"] = ArtifactRef(target="qemu", path=qcow2)
            break

        for vhd in sorted(output_dir.glob("*.vhd*")):
            artifacts["azure"] = ArtifactRef(target="azure", path=vhd)
            break

        for tar_gz in sorted(output_dir.glob("*.tar.gz*")):
            artifacts["gcp"] = ArtifactRef(target="gcp", path=tar_gz)
            break

        return artifacts

    def _ensure_lima_available(self) -> None:
        if shutil.which("limactl") is None:
            raise BackendExecutionError(
                "Lima backend requires `limactl` in PATH.",
                hint="Install Lima: https://lima-vm.io/docs/installation/",
                context={"backend": self.name, "operation": "prepare"},
            )
