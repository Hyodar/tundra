"""Integration test: SDK emission vs real NethermindEth/nethermind-tdx repo.

Compiles the surge_tdx_prover example (full image, all profiles), clones
the upstream repo, and uses codex exec to compare the two project trees
and report differences.
"""

from __future__ import annotations

import importlib.util
import os
import shutil
import subprocess
from pathlib import Path

import pytest

_IMAGE_PATH = Path(__file__).resolve().parent.parent / "examples" / "surge-tdx-prover" / "image.py"
_spec = importlib.util.spec_from_file_location("surge_tdx_prover_image", _IMAGE_PATH)
_mod = importlib.util.module_from_spec(_spec)  # type: ignore[arg-type]
_spec.loader.exec_module(_mod)  # type: ignore[union-attr]
build_surge_tdx_prover = _mod.build_surge_tdx_prover

pytestmark = pytest.mark.integration

# Pin upstream to a known commit; override via UPSTREAM_COMMIT env var.
UPSTREAM_COMMIT = os.environ.get(
    "NETHERMIND_TDX_COMMIT", "7ac44e7d9baecf8743a20e75b30fd4ddfce3e85f"
)

# Required section headers that codex must produce in the report.
REQUIRED_SECTIONS = [
    "## Files only in upstream",
    "## Files only in SDK",
    "## Files in both with differences",
    "## Files that match exactly",
    "## Summary",
]


@pytest.fixture(scope="module")
def sdk_output(tmp_path_factory: pytest.TempPathFactory) -> Path:
    """Compile the full surge-tdx-prover image with all profiles."""
    img = build_surge_tdx_prover()
    # Activate all profiles so the emission includes azure, gcp, devtools
    img._active_profiles = tuple(sorted(img.state.profiles.keys()))
    out = tmp_path_factory.mktemp("sdk_emission")
    img.compile(out / "mkosi")
    return out / "mkosi"


@pytest.fixture(scope="module")
def upstream_repo(tmp_path_factory: pytest.TempPathFactory) -> Path:
    """Clone NethermindEth/nethermind-tdx at a pinned commit."""
    if not shutil.which("git"):
        pytest.skip("git not available")
    repo_dir = tmp_path_factory.mktemp("upstream") / "nethermind-tdx"
    subprocess.run(
        [
            "git",
            "clone",
            "https://github.com/NethermindEth/nethermind-tdx.git",
            str(repo_dir),
        ],
        check=True,
        capture_output=True,
    )
    subprocess.run(
        ["git", "-C", str(repo_dir), "checkout", UPSTREAM_COMMIT],
        check=True,
        capture_output=True,
    )
    return repo_dir


def test_compare_with_upstream(
    sdk_output: Path,
    upstream_repo: Path,
    tmp_path: Path,
) -> None:
    """Use codex to compare SDK output against upstream and report differences."""
    if not shutil.which("codex"):
        pytest.skip("codex CLI not available")

    report_file = tmp_path / "comparison_report.md"

    prompt = f"""\
Compare the complete SDK output against the upstream NethermindEth/nethermind-tdx
repo and produce a structured markdown report of ALL differences.

SDK output (generated by tdxvm SDK, compiled with all profiles):
  {sdk_output}/

Upstream repo (NethermindEth/nethermind-tdx, commit {UPSTREAM_COMMIT}):
  {upstream_repo}/

The SDK compiles a declarative Python image definition into a full mkosi project
tree.  The upstream repo is the source of truth.  Both trees should be
behaviourally equivalent — same packages, same build scripts, same systemd units,
same config files — even though directory layout and script consolidation differ.

## Directory-level mapping

| Upstream directory        | SDK output equivalent                          |
|---------------------------|-------------------------------------------------|
| `base/mkosi.conf`        | `default/mkosi.conf` (merged with app layer)    |
| `base/mkosi.skeleton/`   | `default/mkosi.skeleton/`                       |
| `base/debloat-systemd.sh`| `default/scripts/06-postinst.sh` (embedded)     |
| `base/debloat.sh`        | `default/scripts/07-finalize.sh` (embedded)     |
| `base/add-backports.sh`  | `default/scripts/01-sync.sh`                    |
| `base/efi-stub.sh`       | `default/scripts/06-postinst.sh` (embedded)     |
| `base/remove-image-version.sh` | `default/scripts/07-finalize.sh` (embedded) |
| `kernel/mkosi.build`     | `default/scripts/04-build.sh` (kernel section)  |
| `kernel/kernel-yocto.config` | `default/kernel/kernel.config`              |
| `services/tdxs/build.sh` | `default/scripts/04-build.sh` (tdxs section)    |
| `services/tdx-init/build.sh` | `default/scripts/04-build.sh` (tdx-init section)|
| `services/raiko/build.sh`| `default/scripts/04-build.sh` (raiko section)   |
| `services/taiko-client/build.sh` | `default/scripts/04-build.sh` (taiko section)|
| `services/nethermind/build.sh` | `default/scripts/04-build.sh` (nethermind section)|
| `surge-tdx-prover/mkosi.extra/` | `default/mkosi.extra/` (config, units, scripts)|
| `surge-tdx-prover/mkosi.postinst` | `default/scripts/06-postinst.sh` (embedded)|
| `surge-tdx-prover/mkosi.build`    | `default/scripts/04-build.sh` (part of build)|
| `mkosi.profiles/azure/`  | `azure/` (SDK profile directory)                |
| `mkosi.profiles/gcp/`    | `gcp/` (SDK profile directory)                  |
| `mkosi.profiles/devtools/`| `devtools/` (SDK profile directory)             |

## Semantic mappings for service build scripts

The SDK consolidates all service build scripts into `default/scripts/04-build.sh`.
Each upstream `services/<name>/build.sh` should appear as a section in the SDK
build script with equivalent commands:

- **tdxs**: `git clone`, `cargo build --release` with reproducibility flags,
  install to `/usr/bin/tdxs`
- **tdx-init**: `git clone`, `go build -trimpath -ldflags "-s -w -buildid="`,
  install to `/usr/bin/tdx-init`
- **raiko**: `git clone`, `cargo build` with CARGO_PROFILE_RELEASE_LTO=thin,
  RUSTFLAGS with target-cpu=generic and build-id=none, install to `/usr/bin/raiko`
- **taiko-client**: `git clone`, `go build` with CGO_CFLAGS="-O -D__BLST_PORTABLE__",
  -trimpath -ldflags "-s -w -buildid=", install to `/usr/bin/taiko-client`
- **nethermind**: `git clone`, `dotnet publish` with Deterministic=true,
  ContinuousIntegrationBuild=true, PublishSingleFile=true, install to `/usr/bin/nethermind`

## Config files and systemd units

The SDK emits these into `default/mkosi.extra/` — compare against upstream
`surge-tdx-prover/mkosi.extra/`:

- `/etc/tdx-init/config.yaml` — SSH, key, disk strategy configuration
- `/etc/tdxs/config.yaml` — TDXS quote service config
- `/usr/bin/runtime-init` — runtime initialization script
- `/usr/lib/systemd/system/runtime-init.service`
- `/usr/lib/systemd/system/tdxs.service`, `tdxs.socket`
- `/usr/lib/systemd/system/raiko.service`
- `/usr/lib/systemd/system/taiko-client.service`
- `/usr/lib/systemd/system/nethermind-surge.service`
- `/etc/default/dropbear`, `/etc/sysctl.d/99-surge.conf`
- `/etc/udev/rules.d/65-tdx-guest.rules`
- `/etc/nethermind-surge/env`, `/etc/raiko/env`, `/etc/taiko-client/env`

## Platform profiles

- **azure/**: SDK `azure/mkosi.extra/` should have `azure-complete-provisioning`
  script and service.  SDK `azure/scripts/azure-postoutput.sh` corresponds to
  upstream `mkosi.profiles/azure/mkosi.postoutput` (VHD conversion).
  SDK `azure/scripts/06-postinst.sh` corresponds to upstream `mkosi.profiles/azure/mkosi.postinst`.
- **gcp/**: SDK `gcp/mkosi.extra/` should have `/etc/hosts`, `/etc/resolv.conf`,
  udev rules, `google_nvme_id`.  SDK `gcp/scripts/gcp-postoutput.sh` corresponds
  to upstream `mkosi.profiles/gcp/mkosi.postoutput` (tar.gz).
- **devtools/**: SDK `devtools/mkosi.extra/` should have `serial-console.service`.
  SDK `devtools/scripts/06-postinst.sh` corresponds to upstream
  `mkosi.profiles/devtools/mkosi.postinst` (root password, auth config).

## Instructions

1. Read every file in both trees recursively (upstream and SDK)
2. For each upstream file, find the SDK equivalent using the mappings above
3. Compare behavioural equivalence: same packages, same build commands, same
   config content, same systemd unit structure — even if formatting differs
4. List files in upstream that have NO SDK equivalent (note if intentional)
5. List files in SDK that have no upstream equivalent (note if SDK-generated)
6. For files in both, show key differences
7. Check that ALL five service build scripts have SDK equivalents
8. Check that ALL three platform profiles have SDK equivalents

Output format — write a markdown report to {report_file} with these sections:
- ## Files only in upstream
- ## Files only in SDK
- ## Files in both with differences (show key inline diffs)
- ## Files that match exactly
- ## Summary: total files compared, matches, differences, intentional gaps,
  and a final verdict on behavioral equivalence

Be thorough and precise.  Read every file completely.
Write the report to {report_file}."""

    result = subprocess.run(
        [
            "codex",
            "exec",
            "--dangerously-bypass-approvals-and-sandbox",
            prompt,
        ],
        capture_output=True,
        text=True,
        timeout=600,
    )

    # codex must exit cleanly
    assert result.returncode == 0, (
        f"codex exited with {result.returncode}.\n"
        f"stdout: {result.stdout[-2000:]}\n"
        f"stderr: {result.stderr[-2000:]}"
    )

    assert report_file.exists(), (
        f"codex did not produce report.\n"
        f"stdout: {result.stdout[-2000:]}\n"
        f"stderr: {result.stderr[-2000:]}"
    )

    report = report_file.read_text(encoding="utf-8")
    print(report)  # Always print for visibility in pytest -s

    # Verify the report has the required structure
    for section in REQUIRED_SECTIONS:
        assert section in report, f"Report missing required section: {section}"
